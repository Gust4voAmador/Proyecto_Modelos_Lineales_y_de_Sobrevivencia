for (i in 1:reps) {
# Estratificación del conjunto de entrenamiento
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = p, list = FALSE)
datos_train <- datos_modelo[idx_train, ]
datos_test <- datos_modelo[-idx_train, ]
# Balancear clases en el conjunto de entrenamiento con upSample()
datos_train_balanceado <- upSample(
x = datos_train[, c("Age_woe", "Platelet Count_woe")],
y = datos_train$DengueFactor,
yname = "DengueFactor"
)
# Verificar balance (opcional)
# print(table(datos_train_balanceado$DengueFactor))
# Entrenar modelo logístico
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = datos_train_balanceado,
method = "glm",
trControl = ctrl,
metric = "ROC"
)
# Predicción sobre conjunto de prueba (no balanceado)
pred_test <- predict(modelo, newdata = datos_test, type = "prob")
# Calcular AUC
auc_test <- roc(response = datos_test$DengueFactor,
predictor = pred_test$Sí,
levels = c("No", "Sí"))$auc
# 5. Validación cruzada estratificada (sin balancear)
# Guardar resultados
resultados_balanceados <- rbind(resultados_balanceados,
data.frame(TamanoEntrenamiento = round(p * 100),
Repeticion = i,
AUC_Test = auc_test))
#message("✅ Entrenamiento balanceado con", round(p * 100), "% de datos | Repetición", i,
#    ": AUC en TEST =", round(auc_test, 4), "\n")
}
}
## 6.1 Resultados promedio AUC balanceado
# Mostrar tablas
print(resultados_balanceados)
resumen_balanceados <- aggregate(AUC_Test ~ TamanoEntrenamiento, data = resultados_balanceados, FUN = mean)
print(resumen_balanceados)
set.seed(187)
# Asegurar niveles correctos: "No" (sin dengue), "Sí" (con dengue)
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Proporciones del conjunto de entrenamiento
train_props <- c(0.7, 0.5, 0.3, 0.1)
# Repeticiones por proporción
reps <- 10
# Control de entrenamiento con validación cruzada
ctrl <- trainControl(
method = "cv",
number = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# Inicializar resultados
resultados_balanceados <- data.frame()
for (p in train_props) {
for (i in 1:reps) {
# Estratificación del conjunto de entrenamiento
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = p, list = FALSE)
datos_train <- datos_modelo[idx_train, ]
datos_test <- datos_modelo[-idx_train, ]
# Balancear clases en el conjunto de entrenamiento con upSample()
datos_train_balanceado <- upSample(
x = datos_train[, c("Age_woe", "Platelet Count_woe")],
y = datos_train$DengueFactor,
yname = "DengueFactor"
)
# Verificar balance (opcional)
# print(table(datos_train_balanceado$DengueFactor))
# Entrenar modelo logístico
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = datos_train_balanceado,
method = "glm",
trControl = ctrl,
metric = "ROC"
)
# Predicción sobre conjunto de prueba (no balanceado)
pred_test <- predict(modelo, newdata = datos_test, type = "prob")
# Calcular AUC
auc_test <- roc(response = datos_test$DengueFactor,
predictor = pred_test$Sí,
levels = c("No", "Sí"))$auc
# 5. Validación cruzada estratificada (sin balancear)
# Guardar resultados
resultados_balanceados <- rbind(resultados_balanceados,
data.frame(TamanoEntrenamiento = round(p * 100),
Repeticion = i,
AUC_Test = auc_test))
#message("✅ Entrenamiento balanceado con", round(p * 100), "% de datos | Repetición", i,
#    ": AUC en TEST =", round(auc_test, 4), "\n")
}
}
set.seed(187)
# Asegurar niveles correctos: "No" (sin dengue), "Sí" (con dengue)
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Proporciones del conjunto de entrenamiento
train_props <- c(0.7, 0.5, 0.3, 0.1)
# Repeticiones por proporción
reps <- 10
# Control de entrenamiento con validación cruzada
ctrl <- trainControl(
method = "cv",
number = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# Inicializar resultados
resultados_balanceados <- data.frame()
for (p in train_props) {
for (i in 1:reps) {
# Estratificación del conjunto de entrenamiento
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = p, list = FALSE)
datos_train <- datos_modelo[idx_train, ]
datos_test <- datos_modelo[-idx_train, ]
# Balancear clases en el conjunto de entrenamiento con upSample()
datos_train_balanceado <- upSample(
x = datos_train[, c("Age_woe", "Platelet Count_woe")],
y = datos_train$DengueFactor,
yname = "DengueFactor"
)
# Verificar balance (opcional)
# print(table(datos_train_balanceado$DengueFactor))
# Entrenar modelo logístico
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = datos_train_balanceado,
method = "glm",
trControl = ctrl,
metric = "ROC"
)
# Predicción sobre conjunto de prueba (no balanceado)
pred_test <- predict(modelo, newdata = datos_test, type = "prob")
# Calcular AUC
auc_test <- roc(response = datos_test$DengueFactor,
predictor = pred_test$Sí,
levels = c("No", "Sí"))$auc
# 5. Validación cruzada estratificada (sin balancear)
# Guardar resultados
resultados_balanceados <- rbind(resultados_balanceados,
data.frame(TamanoEntrenamiento = round(p * 100),
Repeticion = i,
AUC_Test = auc_test))
#message("✅ Entrenamiento balanceado con", round(p * 100), "% de datos | Repetición", i,
#    ": AUC en TEST =", round(auc_test, 4), "\n")
}
}
## 6.1 Resultados promedio AUC balanceado
# Mostrar tablas
print(resultados_balanceados)
resumen_balanceados <- aggregate(AUC_Test ~ TamanoEntrenamiento, data = resultados_balanceados, FUN = mean)
print(resumen_balanceados)
set.seed(187)
# Asegurar que la variable respuesta es un factor con clase positiva definida
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Control de validación cruzada clásica (5 folds)
ctrl <- trainControl(
method = "cv",           # Validación cruzada clásica
number = 5,              # 5 pliegues
classProbs = TRUE,       # Necesario para calcular AUC
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# Entrenar modelo con validación cruzada
modelo_cv_clasico <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = datos_modelo,
method = "glm",
metric = "ROC",          # Optimiza AUC
trControl = ctrl
)
# Mostrar resultados de la validación cruzada
print(modelo_cv_clasico)
# Promedio de AUC en los 5 folds
mean(modelo_cv_clasico$resample$ROC)
set.seed(187)
# Asegurar que la variable respuesta es un factor con clase positiva definida
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Control de validación cruzada clásica (5 folds)
ctrl <- trainControl(
method = "cv",           # Validación cruzada clásica
number = 5,              # 5 pliegues
classProbs = TRUE,       # Necesario para calcular AUC
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# Entrenar modelo con validación cruzada
modelo_cv_clasico <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = datos_modelo,
method = "glm",
metric = "ROC",          # Optimiza AUC
trControl = ctrl
)
# Mostrar resultados de la validación cruzada
print(modelo_cv_clasico)
# Promedio de AUC en los 5 folds
mean(modelo_cv_clasico$resample$ROC)
set.seed(187)
# Variable respuesta como factor
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Configuración
reps <- 30  # número de repeticiones
metricas <- data.frame()
for (i in 1:reps) {
# Dividir 30% para entrenamiento, 70% para prueba
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = 0.3, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# Entrenar modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
family = "binomial"
)
# Predicciones
pred_clase <- predict(modelo, newdata = test_data)
pred_prob <- predict(modelo, newdata = test_data, type = "prob")[, "Sí"]
# Matriz de confusión
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
# Calcular AUC
auc <- roc(response = test_data$DengueFactor, predictor = pred_prob, levels = c("No", "Sí"))$auc
# Guardar métricas
metricas <- rbind(metricas, data.frame(
Repeticion = i,
Accuracy = cm$overall["Accuracy"],
Sensitivity = cm$byClass["Sensitivity"],
Specificity = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
AUC = auc
))
}
# Mostrar resultados promedio
resumen_metricas <- data.frame(
Métrica = colnames(metricas)[-1],
Promedio = colMeans(metricas[, -1]),
Desviación = apply(metricas[, -1], 2, sd)
)
print(resumen_metricas)
set.seed(187)
# Variable respuesta como factor
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Configuración
reps <- 30  # número de repeticiones
metricas <- data.frame()
for (i in 1:reps) {
# Dividir 30% para entrenamiento, 70% para prueba
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = 0.3, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# Entrenar modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
family = "binomial"
)
# Predicciones
pred_clase <- predict(modelo, newdata = test_data)
pred_prob <- predict(modelo, newdata = test_data, type = "prob")[, "Sí"]
# Matriz de confusión
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
# Calcular AUC
auc <- roc(response = test_data$DengueFactor, predictor = pred_prob, levels = c("No", "Sí"))$auc
# Guardar métricas
metricas <- rbind(metricas, data.frame(
Repeticion = i,
Accuracy = cm$overall["Accuracy"],
Sensitivity = cm$byClass["Sensitivity"],
Specificity = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
AUC = auc
))
}
# Mostrar resultados promedio
resumen_metricas <- data.frame(
Métrica = colnames(metricas)[-1],
Promedio = colMeans(metricas[, -1]),
Desviación = apply(metricas[, -1], 2, sd)
)
print(resumen_metricas)
set.seed(187)
# Variable respuesta como factor
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Configuración
reps <- 30  # número de repeticiones
metricas <- data.frame()
for (i in 1:reps) {
# Dividir 30% para entrenamiento, 70% para prueba
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = 0.3, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# Entrenar modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
family = "binomial"
)
# Predicciones
pred_clase <- predict(modelo, newdata = test_data)
pred_prob <- predict(modelo, newdata = test_data, type = "prob")[, "Sí"]
# Matriz de confusión
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
# Calcular AUC
auc <- roc(response = test_data$DengueFactor, predictor = pred_prob, levels = c("No", "Sí"))$auc
# Guardar métricas
metricas <- rbind(metricas, data.frame(
Repeticion = i,
Accuracy = cm$overall["Accuracy"],
Sensitivity = cm$byClass["Sensitivity"],
Specificity = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
AUC = auc
))
}
# Mostrar resultados promedio
resumen_metricas <- data.frame(
Métrica = colnames(metricas)[-1],
Promedio = colMeans(metricas[, -1]),
Desviación = apply(metricas[, -1], 2, sd)
)
print(cm)
print(resumen_metricas)
set.seed(187)
# Variable de clase como factor binario
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Repeticiones
reps <- 30
porcentaje_entrenamiento <- 0.3
# Almacenar resultados
metricas <- data.frame()
for (i in 1:reps) {
# 1. Partición estratificada (30% para entrenar)
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = porcentaje_entrenamiento, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# 2. Control de validación cruzada estratificada
ctrl <- trainControl(
method = "cv",
number = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# 3. Modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
metric = "ROC",
trControl = ctrl
)
# 4. Predicción sobre test externo
pred_probs <- predict(modelo, newdata = test_data, type = "prob")
pred_clase <- predict(modelo, newdata = test_data)
# 5. AUC
auc <- roc(response = test_data$DengueFactor,
predictor = pred_probs$Sí,
levels = c("No", "Sí"))$auc
# 6. Matriz de confusión y métricas
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
metricas <- rbind(metricas, data.frame(
Repeticion = i,
AUC = auc,
Accuracy = cm$overall["Accuracy"],
Sensibilidad = cm$byClass["Sensitivity"],
Especificidad = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
Precision = cm$byClass["Precision"]
))
}
# Ver resumen
summary(metricas)
set.seed(187)
# Variable de clase como factor binario
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Repeticiones
reps <- 30
porcentaje_entrenamiento <- 0.3
# Almacenar resultados
metricas <- data.frame()
for (i in 1:reps) {
# 1. Partición estratificada (30% para entrenar)
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = porcentaje_entrenamiento, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# 2. Control de validación cruzada estratificada
ctrl <- trainControl(
method = "cv",
number = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# 3. Modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
metric = "ROC",
trControl = ctrl
)
# 4. Predicción sobre test externo
pred_probs <- predict(modelo, newdata = test_data, type = "prob")
pred_clase <- predict(modelo, newdata = test_data)
# 5. AUC
auc <- roc(response = test_data$DengueFactor,
predictor = pred_probs$Sí,
levels = c("No", "Sí"))$auc
# 6. Matriz de confusión y métricas
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
metricas <- rbind(metricas, data.frame(
Repeticion = i,
AUC = auc,
Accuracy = cm$overall["Accuracy"],
Sensibilidad = cm$byClass["Sensitivity"],
Especificidad = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
Precision = cm$byClass["Precision"]
))
}
# Ver resumen
print(summary(metricas))
resumen_final <- metricas |> summarise(across(where(is.numeric), list(media = mean, sd = sd)))
print(resumen_final)
set.seed(187)
# Variable de clase como factor binario
datos_modelo$DengueFactor <- factor(
ifelse(datos_modelo$`Dengue Diagnosis` == 1, "Sí", "No"),
levels = c("No", "Sí")
)
# Repeticiones
reps <- 30
porcentaje_entrenamiento <- 0.3
# Almacenar resultados
metricas <- data.frame()
for (i in 1:reps) {
# 1. Partición estratificada (30% para entrenar)
idx_train <- createDataPartition(datos_modelo$DengueFactor, p = porcentaje_entrenamiento, list = FALSE)
train_data <- datos_modelo[idx_train, ]
test_data <- datos_modelo[-idx_train, ]
# 2. Control de validación cruzada estratificada
ctrl <- trainControl(
method = "cv",
number = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary,
savePredictions = "final"
)
# 3. Modelo
modelo <- train(
DengueFactor ~ Age_woe + `Platelet Count_woe`,
data = train_data,
method = "glm",
metric = "ROC",
trControl = ctrl
)
# 4. Predicción sobre test externo
pred_probs <- predict(modelo, newdata = test_data, type = "prob")
pred_clase <- predict(modelo, newdata = test_data)
# 5. AUC
auc <- roc(response = test_data$DengueFactor,
predictor = pred_probs$Sí,
levels = c("No", "Sí"))$auc
# 6. Matriz de confusión y métricas
cm <- confusionMatrix(pred_clase, test_data$DengueFactor, positive = "Sí")
metricas <- rbind(metricas, data.frame(
Repeticion = i,
AUC = auc,
Accuracy = cm$overall["Accuracy"],
Sensibilidad = cm$byClass["Sensitivity"],
Especificidad = cm$byClass["Specificity"],
F1 = cm$byClass["F1"],
Precision = cm$byClass["Precision"]
))
}
# Ver resumen
print(summary(metricas))
